package 位运算;
    //网上对原码，反码，补码的解释过于复杂，我这里精简几句话：（背下来）对于有符号的而言：
    //1.二进制的最高位是符号位：0表示正数，1表示负数（老韩口诀：0->0 1->-）
    //2.正数的原码，反码，补码都一样（三码合一）
    //3.负数的反码=它的原码符号位不变，其它位取反（0->1，1->0）
    //4.负数的补码=它的反码+1，负数的反码=负数的补码-1 
    //5.0的反码，补码都是0 
    //6.java没有无符号数，换言之，java中的数都是有符号的
    //7.在计算机运算的时候，都是以补码的方式来运算的. 
    //8.当我们看运算结果的时候，要看他的原码（重点）

    //java 中有 7 个位运算(&、|、^、~、>>、<<和 >>>)
    //分别是按位与&、按位或|、按位异或^，按位取反~，它们的运算规则是：
    //按位与&：两位全为1，结果为1，否则为0
    //按位或|：两位有一个为1，结果为1，否则为0
    //按位异或^:两位一个为0，一个为1，结果为1，否则为0 
    //按位取反~:0->1,1->0
    //比如： 2&3=？ ~-2=？  ~2=？ 2|3=？  2^3=？


public class BitOperator {
	public static void main(String []args) {   
	//推导2&3的结果
	//1：因为在计算机运算的时候，都是以补码的方式来运算的，所以先得到2的补码
	//因为2是正数，2的原码=补码，所以2的补码为 00000000 00000000 00000000 00000010
	//2：得到3的补码
	//因为3是正数，3的原码=补码，所以3的补码为 00000000 00000000 00000000 00000011
	//3：按位与&：两位全为1，结果为1，否则为0
	//            00000000 00000000 00000000 00000010
	//            00000000 00000000 00000000 00000011
	//补码运算结果为    00000000 00000000 00000000 00000010
	//因为看运算结果的时候，要看他的原码，所以将其转换为原码
	//因为该补码为正数所以原码=补码= 00000000 00000000 00000000 00000010=2
	System.out.println(2&3);
	
    //推导  ~-2
	//1：-2的原码为  10000000 00000000 00000000 00000010
	//2：-2的反码为  11111111 11111111 11111111 11111101
	//3：-2的补码为  11111111 11111111 11111111 11111110
	//4：按位取反~:0->1,1->0
	//得到运算后的补码为 00000000 00000000 00000000 00000001
	//因为运算后的补码为正数所以原码=补码= 00000000 00000000 00000000 00000001=1
	System.out.println(~-2);
	
	//推导~2
	//1: 2的补码为   00000000 00000000 00000000 00000010
	//2： ~2操作后    11111111 11111111 11111111 11111101 运算后的补码
	//3： 因为该补码为负数所以 负数的反码=负数的补码-1  得到反码为 11111111 11111111 11111111 11111100
	//4： 负数的反码=它的原码符号位不变，其它位取反  得到原码为 10000000 00000000 00000000 00000011=-3
	System.out.println(~2);
	
	
	

}	
}
